#+TITLE: System Configuration with Guix
#+PROPERTY: :mkdir t

* Table of Contents                                                     :toc:
:PROPERTIES:
:TOC:      :include all :ignore this
:END:
- [[#introduction][Introduction]]
- [[#channels][Channels]]
- [[#systems][Systems]]
  - [[#base-configuration][Base Configuration]]
  - [[#machines][Machines]]
  - [[#usb-installation-image][USB Installation Image]]
- [[#profiles][Profiles]]
  - [[#profile-manifests][Profile Manifests:]]
  - [[#profile-management][Profile Management]]
  - [[#activating-profiles][Activating Profiles]]
  - [[#updating-profiles][Updating Profiles]]
- [[#dotfiles-management][Dotfiles Management]]
  - [[#syncing][Syncing]]
  - [[#updating][Updating]]
  - [[#system-installation][System Installation]]

* Introduction
This file was originally created by David Wilson, and can be seen here:
https://github.com/daviwil/dotfiles
My modifications are made to configure the contents for my systems. 
* Channels

Guix supports the concept of [[https://guix.gnu.org/manual/en/html_node/Channels.html#Channels][channels]] which basically amount to Git repositories which contain Guix package definitions that can be installed on your machine.  Aside from the =%default-channels= list, I also use the [[https://gitlab.com/nonguix/nonguix][Nonguix]] channel to install packages that aren't included with Guix by default like the non-free Linux kernel.

*.config/guix/channels.scm:*

#+begin_src scheme :tangle ./.config/guix/channels.scm

  ;; NOTE: This file is generated from ~/.dotfiles/System.org.  Please see commentary there.

  ;; (cons* (channel
  ;;         (name 'nonguix)
  ;;         (commit "c34fa8bfacdce5fa45b2a684c2b27309c09a9056")
  ;;         (url "https://gitlab.com/nonguix/nonguix"))
  ;;        %default-channels)

  (list (channel
          (name 'nonguix)
          (commit "c34fa8bfacdce5fa45b2a684c2b27309c09a9056")
          (url "https://gitlab.com/nonguix/nonguix"))
        (channel
          (name 'guix)
          (commit "190187326ad7516dd6728eed7bb6ef2d4f92897a")
          (url "https://git.savannah.gnu.org/git/guix.git")
          (introduction
            (make-channel-introduction
              "9edb3f66fd807b096b48283debdcddccfea34bad"
            (openpgp-fingerprint
              "BBB0 2DDF 2CEA F6A8 0D1D  E643 A2A0 6DF2 A33A 54FA")))))

#+end_src

The following channel list can be used when testing patches to packages and services from a local clone of the Guix repo.  You'll have to create a branch and commit changes to it before =guix pull= can pick them up, though.  You can change the target branch using the =branch= field of the =channel=.

#+begin_src scheme :tangle ./.config/guix/channels.scm

;; (list (channel
;;         (name 'nonguix)
;;         (url "https://gitlab.com/nonguix/nonguix"))
;;       (channel
;;         (name 'guix)
;;         (branch "fix-glu-pkg-config")
;;         (url "file:///home/daviwil/Projects/Code/guix")
;;         (introduction
;;           (make-channel-introduction
;;             "d06d5db885e4b8399e878708862fbe3a67f0592c"
;;             (openpgp-fingerprint
;;               "53C4 1E6E 41AA FE55 335A  CA5E 446A 2ED4 D940 BF14")))))

#+end_src

* Systems
** Base Configuration

This base configuration is shared between all of the machines I manage with Guix.  Since all of my machines are Lenovo ThinkPad laptops, the same basic configuration applies pretty cleanly across all of them.  This may change in the future.

Any configuration that derives from =base-operating-system= must invoke =guix system= in a specific way to ensure it gets loaded correctly:

#+begin_src sh

sudo -E guix system -L ~/.dotfiles/.config/guix/systems reconfigure ~/.dotfiles/.config/guix/systems/davinci.scm

#+end_src

*.config/guix/systems/base-system.scm:*

#+begin_src scheme :tangle ./.config/guix/systems/base-system.scm
;; -*- buffer-read-only: t; -*-
;; NOTE: This file is generated from ~/.dotfiles/System.org.  Please see commentary there.

(define-module (base-system)
  #:use-module (gnu)
  #:use-module (srfi srfi-1)
  #:use-module (gnu system nss)
  #:use-module (gnu services pm)
  #:use-module (gnu services cups)
  #:use-module (gnu services desktop)
  #:use-module (gnu services docker)
  #:use-module (gnu services networking)
;;  #:use-module (gnu services virtualization)
  #:use-module (gnu packages wm)
  #:use-module (gnu packages cups)
  #:use-module (gnu packages vim)
  #:use-module (gnu packages gtk)
  #:use-module (gnu packages xorg)
  #:use-module (gnu packages emacs)
  #:use-module (gnu packages gnome)
  #:use-module (gnu packages mtools)
  #:use-module (gnu packages linux)
  #:use-module (gnu packages audio)
  #:use-module (gnu packages gnuzilla)
  #:use-module (gnu packages pulseaudio)
  #:use-module (gnu packages web-browsers)
  #:use-module (gnu packages version-control)
  #:use-module (gnu packages package-management)
  #:use-module (nongnu packages linux)
  #:use-module (nongnu system linux-initrd))

(use-service-modules nix)
(use-service-modules desktop xorg)
(use-service-modules ssh)
(use-package-modules certs)
(use-package-modules shells)

#+end_src

Add a =udev= rule to enable members of the =video= group to control screen brightness.

#+begin_src scheme :tangle ./.config/guix/systems/base-system.scm

;; Allow members of the "video" group to change the screen brightness.
(define %backlight-udev-rule
  (udev-rule
   "90-backlight.rules"
   (string-append "ACTION==\"add\", SUBSYSTEM==\"backlight\", "
                  "RUN+=\"/run/current-system/profile/bin/chgrp video /sys/class/backlight/%k/brightness\""
                  "\n"
                  "ACTION==\"add\", SUBSYSTEM==\"backlight\", "
                  "RUN+=\"/run/current-system/profile/bin/chmod g+w /sys/class/backlight/%k/brightness\"")))

#+end_src

Override the default =%desktop-services= to add the =udev= backlight configuration and include OpenVPN in the list of NetworkManager plugins.

#+begin_src scheme :tangle ./.config/guix/systems/base-system.scm

(define %my-desktop-services
  (modify-services %desktop-services
                   (elogind-service-type config =>
                                         (elogind-configuration (inherit config)
                                                                (handle-lid-switch-external-power 'suspend)))
                   (udev-service-type config =>
                                      (udev-configuration (inherit config)
                                                          (rules (cons %backlight-udev-rule
                                                                       (udev-configuration-rules config)))))
                   (network-manager-service-type config =>
                                                 (network-manager-configuration (inherit config)
                                                                                (vpn-plugins
                                                                                 (list network-manager-openvpn))))))

#+end_src

Use the =libinput= driver for all input devices since it's a bit more modern than the default.

#+begin_src scheme :tangle ./.config/guix/systems/base-system.scm

(define %xorg-libinput-config
  "Section \"InputClass\"
  Identifier \"Touchpads\"
  Driver \"libinput\"
  MatchDevicePath \"/dev/input/event*\"
  MatchIsTouchpad \"on\"

  Option \"Tapping\" \"on\"
  Option \"TappingDrag\" \"on\"
  Option \"DisableWhileTyping\" \"on\"
  Option \"MiddleEmulation\" \"on\"
  Option \"ScrollMethod\" \"twofinger\"
EndSection
Section \"InputClass\"
  Identifier \"Keyboards\"
  Driver \"libinput\"
  MatchDevicePath \"/dev/input/event*\"
  MatchIsKeyboard \"on\"
EndSection
")

#+end_src

Define the =base-operating-system= which will be inherited by all machine configurations.

#+begin_src scheme :tangle ./.config/guix/systems/base-system.scm

(define-public base-operating-system
  (operating-system
    (host-name "base")
    (timezone "Europe/London")
    (locale "en_GB.utf8")

    ;; Use non-free Linux and firmware
    (kernel linux)
    (firmware (list linux-firmware))
    (initrd microcode-initrd)

    ;; Choose UK English keyboard layout, with the extd layout.
    (keyboard-layout (keyboard-layout "gb" "extd" #:model "thinkpad"))

    ;; Use the UEFI variant of GRUB with the EFI System
    ;; Partition mounted on /boot/efi.
    (bootloader (bootloader-configuration
                 (bootloader grub-efi-bootloader)
                 (target "/boot/efi")
                 (keyboard-layout keyboard-layout)))


    ;; Guix doesn't like it when there isn't a file-systems
    ;; entry, so add one that is meant to be overridden
    (file-systems (cons*
                   (file-system
                     (mount-point "/tmp")
                     (device "none")
                     (type "tmpfs")
                     (check? #f))
                   %base-file-systems))

    (users (cons (user-account
                  (name "paul")
                  (comment "Paul Jewell")
                  (group "users")
                  (home-directory "/home/paul")
                  (supplementary-groups '(
                                          "wheel"     ;; sudo
                                          "netdev"    ;; network devices
                                          "kvm"
                                          "tty"
                                          "input"
                                          "docker"
                                          "realtime"  ;; Enable realtime scheduling
                                          "lp"        ;; control bluetooth devices
                                          "audio"     ;; control audio devices
                                          "video")))  ;; control video devices
                 %base-user-accounts))

    ;; Add the 'realtime' group
    (groups (cons (user-group (system? #t) (name "realtime"))
                  %base-groups))

    ;; Install bare-minimum system packages
    (packages (append (list
                        git
                        ntfs-3g
                        exfat-utils
                        fuse-exfat
                        stow
                        neovim
                        i3-wm
                        i3status
                        i3blocks
                        emacs
                        bluez
                        bluez-alsa
                        pulseaudio
                        tlp
                        xf86-input-libinput
                        nss-certs     ;; for HTTPS access
                        gvfs)         ;; for user mounts
                    %base-packages))

    ;; Use the "desktop" services, which include the X11 log-in service,
    ;; networking with NetworkManager, and more
    (services (cons* (service slim-service-type
                              (slim-configuration
                                (xorg-configuration
                                  (xorg-configuration
                                    (keyboard-layout keyboard-layout)
                                    (extra-config (list %xorg-libinput-config))))))
                    (service xfce-desktop-service-type)
                    (service openssh-service-type)
                    (service tlp-service-type
                             (tlp-configuration
                                (cpu-boost-on-ac? #t)
                                (wifi-pwr-on-bat? #t)))
                    (pam-limits-service ;; This enables JACK to enter realtime mode
                     (list
                      (pam-limits-entry "@realtime" 'both 'rtprio 99)
                      (pam-limits-entry "@realtime" 'both 'memlock 'unlimited)))
                    (service thermald-service-type)
                    (service docker-service-type)
                    (service cups-service-type
                             (cups-configuration
                               (web-interface? #t)
                               (extensions
                                 (list cups-filters))))
                    (bluetooth-service #:auto-enable? #t)
                    (remove (lambda (service)
                                (eq? (service-kind service) gdm-service-type))
                            %my-desktop-services)))

    ;; Allow resolution of '.local' host names with mDNS
    (name-service-switch %mdns-host-lookup-nss)))

#+end_src

** Machines

Machines are named after opera stars and greek gods (during initial setup!).

*** Per-System Settings

Some settings need to be customized on a per-system basis without tweaking individual configuration files.  Thanks to org-mode's =noweb= functionality, I can define a set of variables that can be tweaked for each system and applied across these configuration files when they get generated.

I also define a function called =dw/system-settings-get= which can retrieve these settings appropriately.

#+begin_src emacs-lisp :tangle ./.emacs.d/per-system-settings.el :noweb yes

(require 'map) ;; Needed for map-merge

(setq dw/system-settings
  (map-merge
    'list
    '((desktop/dpi . 180)  ;; Need to check this as well with my settings
      (desktop/background . "samuel-ferrara-uOi3lg8fGl4-unsplash.jpg")
      ;; David has a 4K monitor - I suspect these font sizes will be a problem on my monitor
      ;; (emacs/default-face-size . 220)
      ;; (emacs/variable-face-size . 245)
      ;; (emacs/fixed-face-size . 200)
      (polybar/height . 35)
      (polybar/font-0-size . 18)
      (polybar/font-1-size . 14)
      (polybar/font-2-size . 20)
      (polybar/font-3-size . 13)
      (dunst/font-size . 20)
      (dunst/max-icon-size . 88)
      (vimb/default-zoom . 180)
      (qutebrowser/default-zoom . 200))
    <<system-settings>>))

#+end_src


#+begin_src emacs-lisp :tangle .emacs.d/lisp/dw-settings.el

(defun dw/load-system-settings ()
  (interactive)
  (load-file "~/.dotfiles/.emacs.d/per-system-settings.el"))

(defun dw/system-settings-get (setting)
  (alist-get setting dw/system-settings))

(provide 'dw-settings)
#+end_src


**** dw-autorest

#+begin_src emacs-lisp :tangle .emacs.d/lisp/dw-autorest.el
(defvar dw/autorest-last-run nil
  "Details on the last AutoRest run to use with dw/rerun-autorest-command")

(defun dw/rerun-autorest-command ()
  (interactive)
  (if dw/autorest-last-run
      (apply #'dw/run-autorest-command dw/autorest-last-run)
      (message "No previous AutoRest run!")))

(defun dw/run-autorest-command (command-string run-name pre-command)
  (let ((run-message (format "Running AutoRest - %s" command-string)))
    (setq autorest-buffer (get-buffer-create (format "*AutoRest Output: %s*" run-name)))
    (with-current-buffer autorest-buffer
      (ansi-color-for-comint-mode-on)
      (comint-mode)
      (display-line-numbers-mode 0)
      (end-of-buffer)
      (insert "\n"
              (format-time-string "[%m/%d/%Y - %I:%M:%S %p]")
              "\n\n"
              run-message
              "\n\n")
      (when pre-command
        (insert "Pre-run command: " pre-command "\n\n")))

    ;; TODO: This buffer display function isn't perfect
    (message run-message)
    (display-buffer-pop-up-window autorest-buffer '((window-height . 13)))

    (setq dw/autorest-last-run (list command-string run-name pre-command))

    (let ((default-directory "~/Projects/Code/autorest.megarepo/")
          (full-command
             (string-join (list (when pre-command
                                      (format "%s &&" pre-command))
                                "TERM=xterm-256color"
                                command-string)
                          " ")))
      (setq autorest-process (start-process-shell-command "server" autorest-buffer full-command)))

    (set-process-filter autorest-process 'comint-output-filter)))

(cl-defun dw/run-autorest (&key (run-name "adhoc")
                                input-file
                                (use '())
                                language
                                version
                                args
                                (inspector t)
                                debug
                                verbose
                                pre-command)
  (let* ((use-param (mapconcat (lambda (u) (format "--use:%s" u)) use " "))
         (misc-args (mapconcat (lambda (arg) arg) args " "))
         (args (list "autorest"
                     (when language (format "--%s" language))
                     use-param
                     misc-args
                     (if (s-ends-with? ".md" input-file)
                         input-file
                         (format "--input-file:%s" input-file))
                     (when inspector (format "--inspector --inspector.output-folder:./outputs/%s --inspector.clear-output-folder" run-name))
                     (when version (format "--version:%s" version))
                     (when verbose "--verbose")
                     (when debug "--debug")))
         (command-string (string-join args " ")))
    (message command-string)
    (dw/run-autorest-command command-string run-name pre-command)))

;; Keybindings to set up:
;; q - Close panel
;; C-c o - List output files

;; (dw/run-autorest
;;  :run-name "body-formdata"
;;  :language 'python
;;  :input-file "~/Projects/Code/autorest.megarepo/testserver/swagger/body-formdata.json"
;;  :use '("./modelerfour/modelerfour")
;;  :version "./autorest/core"
;;  :pre-command "pushd ./modelerfour/modelerfour && npm run build && popd")

(provide 'dw-autorest)

#+end_src

**** dw-vimb

#+begin_src emacs-lisp :tangle .emacs.d/lisp/dw-vimb.el
(setq dw/open-url-map
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd "<return>") 'ivy-immediate-done)
    map))

(defun dw/open-url ()
  (interactive)
  (let ((history-items
          (with-temp-buffer
            (insert-file-contents "~/.config/vimb/history")
            (split-string (buffer-string) "\n" t))))
    (ivy-read "Open URL: " (remove-duplicates history-items :test #'string-equal)
              :keymap dw/open-url-map
              :action (lambda (item)
                        (start-process "vimb" nil "vimb" (car (split-string item (string ?\t))))))))


#+end_src

*** zeus

zeus is a Lenovo X270 being used as a test bed for guix configuration.

**** *.config/guix/systems/zeus.scm:*

#+begin_src scheme :tangle ./.config/guix/systems/zeus.scm
;; -*- buffer-read-only: t; -*-
;; NOTE: This file is generated from ~/.dotfiles/System.org.  Please see commentary there.
;; Note - if you re-install, you need to review the uuid entries below.

(define-module (zeus)
  #:use-module (base-system)
  #:use-module (gnu))

(operating-system
 (inherit base-operating-system)
 (host-name "zeus")

  (swap-devices
  (list (uuid "74a21e0e-5b14-484b-a448-f8a2fc60d308")))
 (file-systems
  (cons* (file-system
          (mount-point "/boot/efi")
          (device (uuid "139E-0B7E" 'fat32))
          (type "vfat"))
         (file-system
          (mount-point "/")
          (device                       
           (uuid "6dac0fe2-70a5-4a19-8c02-68dd5ebc0f91"
                 'ext4))
          (type "ext4"))
         %base-file-systems)))


#+end_src

**** *System Settings*
These are the emacs configuration settings specific to this
system. Currently they are managed through the site-specific.el file,
generated from [[file+sys:~/.dotfiles/emacs.org][emacs.org]]

#+begin_src emacs-lisp :noweb-ref system-settings :noweb-sep ""

(when (equal system-name "zeus")
  '((*pj/enable-mu4e-mode* . t)
    (*pj/load-site-gentoo* . nil)
    (*pj/enable-auctex* . t)
    (*pj/org-agenda-files* . '("~/Nextcloud/org"))
    (*pj/org-roam-directory* . "~/Nextcloud/org/roam/")
    (*pj/org-roam-db-location* . "~/Nextcloud/org/org-roam.db")))

#+end_src

*** tristan

=tristan= is my main desktop AMD Ryzen 9 system, running =gentoo linux=,
and dual booting into =windows=.

Currently, there is no guix installation on this system, but there is
emacs on both operating systems.

System Settings

#+begin_src emacs-lisp :noweb-ref system-settings :noweb-sep ""
(when (equal system-name "tristan")
   '((*pj/enable-mu4e-mode* . t)
    (*pj/load-site-gentoo* . t)
    (*pj/enable-auctex* . nil)
    (*pj/org-agenda-files* . '("~/Nextcloud/org"))
    (*pj/org-roam-directory* . "~/Nextcloud/org/roam/")
    (*pj/org-roam-db-location* . "~/Nextcloud/org/org-roam.db")))

(when (string= "windows-nt" system-type))
#+end_src
*** Rodolfo

=rodolfo= is a lenovo x270 laptop with gentoo linux installed.
*System settings*
#+begin_src emacs-lisp :noweb-ref system-settings :noweb-sep ""
(when (equal system-name "rodolfo")
   '((*pj/enable-mu4e-mode* . t)
    (*pj/load-site-gentoo* . t)
    (*pj/enable-auctex* . t)
    (*pj/org-agenda-files* . '("~/Nextcloud/org"))
    (*pj/org-roam-directory* . "~/Nextcloud/org/roam/")
    (*pj/org-roam-db-location* . "~/Nextcloud/org/org-roam.db")))

#+end_src
*** Shingo
=shingo= is a small computer in the shed. Currently has gentoo, but will
be the next candidate for guix.
*System Settings*
#+begin_src emacs-lisp :noweb-ref system-settings :noweb-sep ""
(when (equal system-name "tristan")
   '((*pj/enable-mu4e-mode* . t)
    (*pj/load-site-gentoo* . t)
    (*pj/enable-auctex* . t)
    (*pj/org-agenda-files* . '("~/Nextcloud/org"))
    (*pj/org-roam-directory* . "~/Nextcloud/org/roam/")
    (*pj/org-roam-db-location* . "~/Nextcloud/org/org-roam.db")))
#+end_src
** USB Installation Image

To install Guix on another machine, you first to build need a USB image.  Since I use modern laptops that require non-free components, I have to build a custom installation image with the full Linux kernel.  I also include a few other programs that are useful for the installation process.  I adapted this image from [[https://gitlab.com/nonguix/nonguix/blob/master/nongnu/system/install.scm][one found on the Nonguix repository]], hence the copyright header.

*.config/guix/systems/install.scm:*

#+begin_src scheme :tangle ./.config/guix/systems/install.scm

;;; Copyright © 2019 Alex Griffin <a@ajgrf.com>
;;; Copyright © 2019 Pierre Neidhardt <mail@ambrevar.xyz>
;;; Copyright © 2019 David Wilson <david@daviwil.com>
;;;
;;; This program is free software: you can redistribute it and/or modify
;;; it under the terms of the GNU General Public License as published by
;;; the Free Software Foundation, either version 3 of the License, or
;;; (at your option) any later version.
;;;
;;; This program is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;;
;;; You should have received a copy of the GNU General Public License
;;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

;; Generate a bootable image (e.g. for USB sticks, etc.) with:
;; $ guix system disk-image nongnu/system/install.scm

(define-module (nongnu system install)
  #:use-module (gnu system)
  #:use-module (gnu system install)
  #:use-module (gnu packages version-control)
  #:use-module (gnu packages vim)
  #:use-module (gnu packages linux)
  #:use-module (gnu packages mtools)
  #:use-module (gnu packages package-management)
  #:use-module (nongnu packages linux)
  #:export (installation-os-nonfree))

(define installation-os-nonfree
  (operating-system
    (inherit installation-os)
    (kernel linux)
    (firmware (list linux-firmware))

    ;; Add some extra packages useful for the installation process
    (packages
     (append (list git exfat-utils fuse-exfat stow vim)
             (operating-system-packages installation-os)))))

installation-os-nonfree

#+end_src

* Profiles
Packages are installed into separate manifests that get installed as
profiles which can be updated independently.  These profiles get
installed under the =~/.guix-extra-profiles= path and sourced by
=~/.profile= when I log in.
** Profile Manifests:
*** Browsers
#+begin_src scheme :tangle .config/guix/manifests/browsers.scm
(specifications->manifest
 '("ungoogled-chromium"
   "firefox"))
#+end_src

*** Code
#+begin_src scheme :tangle .config/guix/manifests/code.scm
  ;; Various developer tools that I use.  These might be split out into
  ;; platform-specific manifests at some point.

       "texinfo"
     "llvm"
     "lld"
     "clang"

     ;; Python
     "python3"

     ;; Docker
     "docker-cli"

     ;; Java
     "icedtea"

     ;; Lisp
     "sbcl"

     ;; Clojure
     "clojure"
     "leiningen"
   
     ;; SDL
     "glu"
     "glfw"
     "sdl2"
     "sdl2-image"
     "sdl2-mixer"
     "sdl2-gfx"
     "sdl2-ttf"

     "curl"
     "virt-manager"))
     ;; "glibc" ;; For ldd
#+end_src

*** Games
#+begin_src scheme  :tangle .config/guix/manifests/games.scm
(specifications->manifest
 '("aisleriot"
   "gnome-mahjongg"))

#+end_src

*** Music Creation
#+begin_src scheme :tangle .config/guix/manifests/music.scm
;; Music creation tools

(specifications->manifest
 '(;; JACK tools
   "jack"
   "jack2"
   "jack-keyboard"
   "qjackctl"
   "patchage"

   ;; DAWs
   "ardour"
   "zrythm"

   ;; Guitar
   ;; "guitarix"
   ;; "guitarix-lv2"

   ;; Effects
   "calf"
   "g2reverb"
   "dragonfly-reverb"
   "wolf-shaper"

   ;; Synths
   "helm"
   "amsynth"
   "avldrums-lv2"
   "geonkick"
   "fluidsynth"
   "zynaddsubfx"

   ;; Mixing Tools
   "wolf-spectrum"))
#+end_src

*** Video Creation Tools
#+begin_src scheme :tangle .config/guix/manifests/video.scm
;; Video creation tools

(specifications->manifest
 '(;; Screen Capture and Streaming
   "obs"
   "ffmpeg"    ;; ffmpeg and ffplay
   "v4l-utils" ;; Get details about webcams: v4l2-ctl --list-devices

   ;; Screen recording with pulseaudio source 0 (-i 0)
   ;; ffmpeg -y -f x11grab -video_size 2560x1440 -i :0.0+0,0 -f pulse -ac 2 -i 0 -c:v libx264 -pix_fmt yuv420p -crf 0 -preset ultrafast ~/output.mp4 -v 0

   ;; Scaling video down to 1080p
   ;; ffmpeg -i output2.mp4 -s 1920x1080 ~/output2-scaled.mp4

   ;; Show webcam with specific resolution
   ;; ffplay -f v4l2 -framerate 60 -video_size hd480 /dev/video2 -v 0

   ;; Video Editing
   "blender"))
#+end_src
** Profile Management
To make the management of multiple profiles easier, I've created a couple of shell scripts:

** Activating Profiles

This script accepts a space-separated list of manifest file names (without extension) under the =~/.config/guix/manifests= folder and then installs those profiles for the first time.  For example:

#+begin_src sh

activate-profiles desktop emacs music

#+end_src

*.bin/activate-profiles:*

#+begin_src sh :tangle ./.bin/activate-profiles :shebang #!/bin/sh
# -*- buffer-read-only: t; -*-
# NOTE: This file is generated from ~/.dotfiles/System.org.  Please see commentary there.

if [ $HOSTNAME = "zeus" ] # This will need modification when expanding number of guix systems.
                          # Currently zeus is the only one.
then
  GREEN='\033[1;32m'
  RED='\033[1;30m'
  NC='\033[0m'
  GUIX_EXTRA_PROFILES=$HOME/.guix-extra-profiles

  profiles=$*
  if [[ $# -eq 0 ]]; then
    profiles="$HOME/.config/guix/manifests/*.scm";
  fi
  
  for profile in $profiles; do
    # Remove the path and file extension, if any
    profileName=$(basename $profile)
    profileName="${profileName%.*}"
    profilePath="$GUIX_EXTRA_PROFILES/$profileName"
    manifestPath=$HOME/.config/guix/manifests/$profileName.scm
    
    if [ -f $manifestPath ]; then
      echo
      echo -e "${GREEN}Activating profile:" $manifestPath "${NC}"
      echo
      
      mkdir -p $profilePath
      guix package --manifest=$manifestPath --profile="$profilePath/$profileName"
      
      # Source the new profile
      GUIX_PROFILE="$profilePath/$profileName"
      if [ -f $GUIX_PROFILE/etc/profile ]; then
        . "$GUIX_PROFILE"/etc/profile
      else
        echo -e "${RED}Couldn't find profile:" $GUIX_PROFILE/etc/profile "${NC}"
      fi
    else
      echo "No profile found at path" $profilePath
    fi
  done
fi

#+end_src

** Updating Profiles

This script accepts a space-separated list of manifest file names (without extension) under the =~/.config/guix/manifests= folder and then installs any updates to the packages contained within them.  If no profile names are provided, it walks the list of profile directories under =~/.guix-extra-profiles= and updates each one of them.

#+begin_src sh

update-profiles emacs

#+end_src

*.bin/update-profiles:*

#+begin_src sh :tangle ./.bin/update-profiles :shebang #!/bin/sh
# -*- buffer-read-only: t; -*-
# NOTE: This file is generated from ~/.dotfiles/System.org.  Please see commentary there.

GREEN='\033[1;32m'
NC='\033[0m'
GUIX_EXTRA_PROFILES=$HOME/.guix-extra-profiles

profiles=$*
if [[ $# -eq 0 ]]; then
    profiles="$GUIX_EXTRA_PROFILES/*";
fi

for profile in $profiles; do
  profileName=$(basename $profile)
  profilePath=$GUIX_EXTRA_PROFILES/$profileName

  echo
  echo -e "${GREEN}Updating profile:" $profilePath "${NC}"
  echo

  guix package --profile="$profilePath/$profileName" --manifest="$HOME/.config/guix/manifests/$profileName.scm"
done

#+end_src

* Dotfiles Management

Since I keep all of my important configuration files in Org Mode code
blocks, I have to ensure that the real configuration files are kept up
to date when I sync the latest changes to my [[https://github.com/daviwil/dotfiles][dotfiles]] repo.  I've
written a couple of scripts to simplify that process:

** Syncing

When I want to sync my dotfiles repo into my local clone which likely has uncommitted changes, I run =sync-dotfiles=.  This script first makes sure that all Org files are saved in a running Emacs instance and then stashes everything before pulling the latest changes from =origin=.  After pulling, the stash is popped and then the script verifies there are no merge conflicts from the stash before proceeding.  If there are no conflicts, =update-dotfiles= is run, otherwise I'll fix the merge conflicts manually and run =update-dotfiles= myself.

*.bin/sync-dotfiles*

#+begin_src sh :tangle ./.bin/sync-dotfiles :shebang #!/bin/sh
# -*- buffer-read-only: t; -*-
# Sync dotfiles repo and ensure that dotfiles are tangled correctly afterward

GREEN='\033[1;32m'
BLUE='\033[1;34m'
RED='\033[1;30m'
NC='\033[0m'

# Navigate to the directory of this script (generally ~/.dotfiles/.bin)
cd $(dirname $(readlink -f $0))
cd ..

echo
echo -e "${BLUE}Saving Org buffers if Emacs is running...${NC}"
emacsclient -u -e "(org-save-all-org-buffers)" -a "echo 'Emacs is not currently running'"

echo -e "${BLUE}Stashing existing changes...${NC}"
stash_result=$(git stash push -m "sync-dotfiles: Before syncing dotfiles")
needs_pop=1
if [ "$stash_result" = "No local changes to save" ]; then
    needs_pop=0
fi

echo -e "${BLUE}Pulling updates from dotfiles repo...${NC}"
echo
git pull origin master
echo

if [[ $needs_pop -eq 1 ]]; then
    echo -e "${BLUE}Popping stashed changes...${NC}"
    echo
    git stash pop
fi

unmerged_files=$(git diff --name-only --diff-filter=U)
if [[ ! -z $unmerged_files ]]; then
   echo -e "${RED}The following files have merge conflicts after popping the stash:${NC}"
   echo
   printf %"s\n" $unmerged_files  # Ensure newlines are printed
else
    update-dotfiles
fi

#+end_src

** Updating

Updating my dotfiles requires running a script in Emacs to loop over
all of my literate configuration =.org= files and run
=org-babel-tangle-file= to make sure all of my configuration files are
up to date.

*.bin/update-dotfiles*
*.emacs.d/tangle-dotfiles.el*

These two files is already in the .bin and .emacs.d directory
respectively. Otherwise it's not straight forward to tangle all of the
.org files.

** System Installation

Until I migrate its Markdown contents into Org syntax, consult [[file:.config/guix/systems/README.md][.config/guix/systems/README.md]] for installation instructions.
